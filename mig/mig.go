package mig

import (
    "bytes"
    "fmt"
    "io/ioutil"
    "path"
    "sort"
    "text/template"
    "time"

    "github.com/pkg/errors"
)

// Registered migrations.
var migrations = make(map[string][]Migration)

// Register registers Migration.
func Register(target string, migration Migration) {
    migrations[target] = append(migrations[target], migration)
}

// A Mig is a migrations manager.
type Mig struct {
    cfg    Config
    driver Driver
    migDir string
    target string
}

// NewMig returns new Mig instance.
func NewMig(cfg Config, target string) (*Mig, error) {
    // Make sure migrations directory exist.
    migDir := path.Join(cfg.MigDir(), "migrations")
    if err := checkCreateDir(migDir); err != nil {
        return nil, err
    }
    // Sort all registered migrations.
    for _, mgr := range migrations {
        sort.Sort(migSort(mgr))
    }
    // Get driver for selected target.
    driver, err := NewDriverProvider(cfg).Driver(target)
    if err != nil {
        return nil, err
    }
    // Merge filesystem an database info about migrations for given target.
    if err := driver.Merge(migrations[target]); err != nil {
        return nil, err
    }
    m := &Mig{
        cfg:    cfg,
        driver: driver,
        target: target,
        migDir: migDir,
    }
    // Validate migrations.
    if err := m.validateMigs(); err != nil {
        return nil, err
    }
    return m, nil
}

// CreateMigration creates new migration file for given target name.
func (m *Mig) CreateMigration() error {
    version := time.Now().UnixNano()
    if err := m.driver.Creator().CreateMigration(version); err != nil {
        return err
    }
    m.createMain()
    return nil
}

func (m *Mig) Initialize() error {
    return m.driver.Initialize()
}

// Migrate migrates database target to specific version.
// If version is -1 it will migrate database to latest version.
func (m *Mig) Migrate(to int64) error {
    v, err := m.driver.Version()
    if err != nil {
        return err
    }
    fmt.Println(v) // TODO: remove this
    return nil
}

func (m *Mig) Status() error {
    v, err := m.driver.Version()
    if err != nil {
        return err
    }
    fmt.Println(v) // TODO: remove this
    return nil
}

// createMain creates main.go.
func (m *Mig) createMain() error {
    main := path.Join(m.migDir, "main.go")
    var data = struct {
        Names []string
    }{}
    for _, n := range m.cfg.Targets() {
        if ok, _ := isDir(path.Join(m.migDir, n)); ok {
            data.Names = append(data.Names, n)
        }
    }
    var buf bytes.Buffer
    if err := mainTpl.Execute(&buf, data); err != nil {
        return errors.WithStack(err)
    }
    if err := ioutil.WriteFile(main, buf.Bytes(), 0666); err != nil {
        return errors.WithStack(err)
    }
    return nil
}

// validateMigs validates migrations list for given target.
func (m *Mig) validateMigs() error {
    // No migrations no possibility for error.
    if len(migrations[m.target]) == 0 {
        return nil
    }
    prev := migrations[m.target][0].AppliedAt().IsZero()
    for _, mgr := range migrations[m.target] {
        curr := mgr.AppliedAt().IsZero()
        switch {
        case prev == false && curr == true:
            return errors.New("migrations are not continuous")
        default:
            prev = curr
        }
    }
    return nil
}

var mainTpl = template.Must(template.New("registry-mysqlDriver-struct-tpl").Parse(`package main

import ({{ range $name := .Names }}
    _ "./{{ $name }}"{{ end }}
    "github.com/rzajac/mig/cmd/mig/cmd"
)

// ======================= DO NOT EDIT THIS FILE =======================

func main() {
    cmd.Execute()
}
`))
